{"version":3,"sources":["audioFX.js"],"names":[],"mappings":"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","file":"audioFX.js","sourcesContent":["\"use strict\";\n/*global window,AudioContext,XMLHttpRequest */\n\nclass audioFX {\n\n  /**\n   * Instantiates a new audioFX instance, should be called after the window has loaded.\n   * @constructor\n   * @param {string} url - A URL where to load the file from.\n   * @param {object} options - Custom options on instance level.\n   * @param {function} callback - A function that gets called once the buffer has been loaded and we are ready for playback.\n   */\n  constructor(url, options, callback) {\n    // set constants\n    this.const = {\n      QUALITY_MULTIPLIER: 30\n    };\n    // set defaultOptions\n    let defaultOptions = {\n      loop: false,\n      filterFrequency: 5000\n    };\n    // overwrite defaults with supplied options â€“ if an object is supplied\n    if(this.isObject(options)) {\n      this.options = this.extend(defaultOptions, options);\n    }\n    // initialize the instance vars\n    this.playing = false;\n    // init context with prefixes\n    try {\n      window.AudioContext = window.AudioContext||window.webkitAudioContext;\n      this.context = new AudioContext();\n    }catch(e) {\n      this.error('Web Audio API is not supported in this browser');\n    }\n    // register the supplied url, I'd say there's no valid-URL-check necessary\n    this.url = url;\n    // if the callback is really a function, register it\n    if(this.isFunction(callback)) {\n      this.onload = callback;\n    }else{\n      this.error(\"Supplied callback is not a function.\");\n    }\n    // register empty buffer var\n    this.buffer = null;\n    // create buffer source\n    this.source = this.context.createBufferSource();\n    // set looping option\n    if(this.options.loop){\n      this.source.loop = true;\n    }\n    // normalize browser syntax\n    if (!this.context.createGain) {\n      this.context.createGain = this.context.createGainNode;\n    }\n    // create gain node\n    this.gainNode = this.context.createGain();\n    // create filter node\n    this.filter = this.context.createBiquadFilter();\n    // filter.type is defined as string type in the latest API. But this is defined as number type in old API.\n    this.filter.type = (typeof this.filter.type === 'string') ? 'lowpass' : 0; // LOWPASS\n    this.filter.frequency.value = this.options.filterFrequency;\n    // if there's directly a url provided, the load it\n    this.loadFile(url);\n    // no return needed for constructor\n  }\n\n  /**\n   * Loads a file from an URL\n   * @param {string} url - A URL where to load the file from.\n   */\n  loadFile(url){\n    // Load buffer asynchronously\n    this.request = new XMLHttpRequest();\n    // issue a GET request to the url, the true flag makes it async\n    this.request.open(\"GET\", url, true);\n    // set the responseType to Arraybuffer\n    this.request.responseType = \"arraybuffer\";\n    // create reference for the async onload function\n    var instance = this;\n    // define what happens when we get a response from the request\n    this.request.onload = function() {\n      // Asynchronously decode the audio file data in request.response\n      instance.context.decodeAudioData(\n        // the arrayBuffer we received\n        instance.request.response,\n        // do this with it\n        function(buffer) {\n          // if we don't have a buffer, throw an error\n          if (!buffer) {\n            instance.error('Error decoding file data: ' + url);\n            return;\n          }\n          // otherwise save the buffer\n          instance.buffer = buffer;\n          // and fire the callback\n          instance.onload(instance.bufferList);\n          // load buffer in source\n          instance.connectNodes(this.buffer);\n        },\n        // if you can't make it, tell me why\n        function(error) {\n          instance.error('Error at decodeAudioData', error);\n        }\n      );\n    };\n    // bind error function in case things go wrong\n    this.request.onerror = function() {\n      this.error(\"XMLHttpRequest errored.\");\n    };\n    // actually send the request we created\n    this.request.send();\n  }\n\n  /**\n   * Connects the nodes after a buffer has loaded\n   * @param {object} buffer - A buffer that gets connected to the source\n   */\n  connectNodes(buffer){\n    // assign buffer to source\n    this.source.buffer = buffer;\n    // connect source to filter to gain node\n    this.source.connect(this.filter);\n    this.filter.connect(this.gainNode);\n    this.gainNode.connect(this.context.destination);\n  }\n\n  /**\n   * Plays the Audio\n   * @param {number} when - The when parameter defines when the play will start. If when represents a time in the past, the play will start immediately.\n   * @param {number} offset - The offset parameter, which defaults to 0, defines where the playback will start.\n   * @param {number} duration - The duration parameter, which defaults to the length of the asset minus the value of offset, defines the length of the portion of the asset to be played.\n   */\n  play(when = 0, offset = 0, duration = 0){\n    // normalize browser syntax\n    if (!this.source.start) {\n      this.source.start = this.source.noteOn;\n    }\n    // play\n    this.source.start(when,offset,duration);\n  }\n\n  /**\n   * Stops the audio\n   * @param {number} when - The when parameter defines when the playback will stop. If it represents a time in the past, the playback will end immediately.\n   */\n  stop(when = 0){\n    // if there is an old version of the API\n    if (!this.source.stop) {\n      // shim stop from noteOff\n      this.source.stop = this.source.noteOff;\n    }\n    // now actually do it\n    this.source.stop(when);\n  }\n\n  /**\n   * Play/Pause toggles the audio\n   */\n  toggle(){\n    // If we are playing\n    if(this.playing){\n      // then stop\n      this.stop();\n    }else{\n      // otherwise we have stopped, so play\n      this.play();\n    }\n    // toggle the opposite of the current Boolean\n    this.playing = !this.playing;\n  }\n\n  /**\n   * Changes the volume of the instance\n   * @param {number} volume - the volume (supply a fraction like 0.5)\n   */\n  changeVolume(volume){\n    // parse the input to make sure we have a number to work with\n    let fraction = parseFloat(volume);\n    // Let's use an x*x curve (x-squared) since simple linear (x) does not sound as good.\n    this.gainNode.gain.value = fraction * fraction;\n  }\n\n  /**\n   * Changes the filter of the instance\n   * @param {number} frequency - the frequency of the filter (supply an integer like 50)\n   * @param {number} quality - the volume (supply an integer like 5)\n   */\n  changeFilter(frequency,quality){\n    // Clamp the frequency between the minimum value (40 Hz) and half of the sampling rate.\n    let minValue = 40;\n    let maxValue = this.context.sampleRate / 2;\n    // Logarithm (base 2) to compute how many octaves fall in the range.\n    let numberOfOctaves = Math.log(maxValue / minValue) / Math.LN2;\n    // Compute a multiplier from 0 to 1 based on an exponential scale.\n    let multiplier = Math.pow(2, numberOfOctaves * (frequency - 1.0));\n    // Get back to the frequency value between min and max.\n    this.filter.frequency.value = maxValue * multiplier;\n    this.filter.Q.value = quality * this.const.QUALITY_MULTIPLIER;\n  }\n\n  /**\n   * Destroys the instance, make sure to clean all reference to it for Garbage Collection\n   */\n  destroy(){\n    let self = this;\n    self = null;\n  }\n\n  // SYNTACTIC SUGAR\n\n  // just syntactic sugar over changeVolume\n  volume(v){\n    return this.changeVolume(v);\n  }\n  // just syntactic sugar over changeFilter\n  filter(f,q){\n    return this.changeFilter(f,q);\n  }\n  // just syntactic sugar over destroy\n  kill(){\n    return this.destroy();\n  }\n  // just syntactic sugar over destroy\n  remove(){\n    return this.destroy();\n  }\n\n  // HELPER FUNCTIONS FOR INDEPENDENCE\n\n  /**\n   * Extends an object with values from a seconds object. Used for options overwriting\n   * @param {object} a - the first object with default values\n   * @param {object} b - the second object with values that should overwrite the first one\n   */\n  static extend(a, b){\n    for(var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n    return a;\n  }\n\n  /**\n   * Checks if the supplied argument is an object and not null\n   * @param {object} obj - the argument to check\n   */\n  static isObject(obj){\n    return obj !== null && typeof obj === 'object';\n  }\n\n  /**\n   * Checks if the supplied argument is a function\n   * @param {function} functionToCheck - the argument to check\n   */\n  static isFunction(functionToCheck) {\n    var getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n  }\n\n  /**\n   * Centralized error handling\n   * @param {string} errorMessage - the message for output\n   */\n  static error(errorMessage){\n    return console.error('audioFX: Error! '+errorMessage);\n  }\n\n}\n"],"sourceRoot":"/source/"}